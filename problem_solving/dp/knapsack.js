const n = 3;
const wMax = 8;
const wList = [3, 4, 5];
const valueList = [30, 50, 60];

const make2dArray = (i, j, value = 0) => {
  const array = Array(i);
  for (let a = 0; a < i; a++) {
    array[a] = [];
    for (let b = 0; b < j; b++) {
      array[a][b] = value;
    }
  }
  return array;
};

// i番目までの品物を入れることにしたとき、かつ重さの総和がjまでにしたときのナップザック内の価値の総和の最大値
// i,もjも0番目は何も選択しなかったときに使ってしまうので1個余分にとらないといけない。最終的な答えもdp[n][wMax]
const dp = make2dArray(n + 1, 8 + 1);

// 一応明示的に初期条件を書いておく。今回は配列のデフォルトで吸収できているけども。
for (let i = 0; i < wMax; i++) {
  dp[0][i] = 0;
}

for (let i = 0; i < n; i++) {
  for (let j = 0; j <= wMax; j++) {
    // i番目入れられるとき
    // dp[i+1][j]はi番目までの品物を選んだ場合というように添え字がずれることに注意。なぜならdp[0][j]が何も選ばなかったときにしているから。
    // だから下の左辺はi番目まで選んだときだし、右辺はi-1番目まで選んだ時である
    //
    // また、下はなぜこうなるかというと、dp[i][j]の時点でi-1個目までの品物での重さjまでの「最大値（最適解）」が選ばれているはずである。
    // i個目を選ぶと、自動的に重さw[i]は必要である。では、i個目を選んだ時に最大となるかはわからないが、もしも適用するならば、その分のスペースは空けてもらった上での状態に反映しなくてはならない。
    // なので、いったん最大となるかはわからないが、その候補となりうるとしたら、過去にそれを差っ引いた時であり、中でも特に差っ引いた範囲の中での最大値に対して、今回の選択を適用したときがわかるとなおよい。それがなんと求まっている。
    // それはつまりdp[i][j - w[i]] + valueList[i]
    // あくまでもi個目を入れたときに最大候補となるのが上記というだけで、最大となるかはわかならい。でも、その場合は別に緩和する（最大だったら更新してあげる。それ以外は無視）ならば問題ない。
    // よって緩和処理を入れる。これが終わってこそ最大となるのでdp[i+1][j]=という式の右辺に入れられる。
    // 上記は、今までの最大値が求まっているからこそできている。そこまでが最適だったなら、今回の選択肢としてありうるものを過去のある時点の最適に適用してあげればそれだけが最適の候補である。余計なものを大幅に無視できる。
    // この、過去のある時点を最適だと信じてあげられることがだいぶ効いている。もし、今回も最適となりうるならばその場合は過去のある時点も最適でないといけない。
    if (j - wList[i] >= 0) {
      dp[i + 1][j] = Math.max(dp[i][j], dp[i][j - wList[i]] + valueList[i]);
    } else {
      // i番目入れられないとき
      // 考え方てきには緩和として、Math.max(dp[i][j], dp[i][j])と思ってもいいかもしれない
      dp[i + 1][j] = dp[i][j];
    }
  }
}

console.log(dp[n][wMax]);
